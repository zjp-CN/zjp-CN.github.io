---
title: 【笔记】rCore (RISC-V)：GDB 使用记录
date: 2024-04-25 20:00:00 +0800
categories: [rCore, RISC-V, GDB]
tags: [rCore, RISC-V, GDB]
img_path: /assets/img/rcore
---

# 安装 GDB


GDB 需要针对 riscv64 平台编译的版本才能用来调试内核，其二进制文件为 `riscv64-unknown-elf-gdb`。

rCore 教程的[配置环境][gdb2020]一章给了 GDB 预编译二进制的下载链接，但那是在 2020 年版本了。

最大的缺点在于不支持 TUI 插件和 [dbg-dashboard](https://github.com/cyrus-and/gdb-dashboard/)。

[gdb2020]: https://learningos.cn/rCore-Tutorial-Guide-2024S/0setup-devel-env.html#gdb

所以，为了愉快地调试代码，需要自己编译最新的 GDB。GDB 编译流程在老教程里是有[介绍的][rcore-gdb]，但仍然有内容过时。

[rcore-gdb]: https://rcore-os.cn/rCore-Tutorial-deploy/docs/pre-lab/gdb.html

下面我记录自己的编译命令，基于 Ubuntu 系统：

```bash
# 1. 首先一些依赖项，其中 libncurses5-dev 提供了 TUI 库（--enable-tui 需要它)
sudo apt-get install libncurses5-dev texinfo libreadline-dev # python python-dev 
# 这里的 python 和 python-dev 并不必须是 python2，我本地的默认 python 就是 3，可以编译成功并且正常使用

# 2. 检查本地 python 路径
which python # 或者 ll $(which python) 查看链接到那个 python，我的是 /usr/local/sbin/python -> /usr/bin/python3

# 3. 下载最新的 GDB 源码，清华镜像地址： https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/?C=M&O=D
wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/gdb-14.2.tar.xz

# 4. 解压缩它（你可以使用 tar 命令，我懒得查和记，因为我一直使用 ouch ），源码在 $PWD/gdb-14.2/ 文件夹下 
ouch d gdb-14.2.tar.xz

# 5. 进入这个目录，并在里面创建另一个目录，用来存放编译结果和二进制文件
cd gdb-14.2
mkdir build-riscv64

# 适当阅读一下 gdb-14.2/gdb/README，这可是 GDB 的官方安装说明

# 6. 进入 gdb-14.4/build-riscv64 目录，准备编译
cd build-riscv64
../configure --prefix=/root/qemu/gdb-14.2/build-riscv64 --with-python=/usr/local/sbin/python --target=riscv64-unknown-elf --enable-tui=yes

# 7. 编译并生成二进制文件 
make -j$(nproc)
make install

# 8. 编译好的 GDB 存放在 build-riscv64/bin/ 目录下，你可以只保留这个目录，然后添加这个目录到环境变量。
# 确认 GDB 可以运行
./bin/riscv64-unknown-elf-gdb --version
# 在 `~/.bashrc` 文件中，添加以下一行，然后开启新的终端（或者重启终端），那么 
export PATH="/root/qemu/gdb-14.2/build-riscv64/bin:$PATH"

# 9. 安装 gdb-dashboard：仅仅是下载一个 python 文件到 ~/.gdbinit 来做 gdb 的启动拓展
wget -P ~ https://github.com/cyrus-and/gdb-dashboard/raw/master/.gdbinit
```


![带 TUI 的 GDB](./gdb-riscv64.gif)

# GDB 脚本

为了方便自己调试任意 riscv 程序，我自己编写了一个 shell 脚本 `gdb.sh`：

```bash
#!/bin/sh
cmd=$1
binfile=$2

case $cmd in
'start')
  riscv64-unknown-elf-gdb \
    -ex "file $binfile" \
    -ex 'set arch riscv:rv64' \
    -ex 'target remote localhost:1234'
  ;;
'serve')
  qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ./bootloader/rustsbi-qemu.bin \
    -device loader,file=$binfile,addr=0x80200000 \
    -s -S
  ;;
*)
  echo 'start/serve + binfile-path'
  ;;
esac
```

给这个脚本添加执行权限 `chmod +x gdb.sh`，搭配首行的 shebang 语法，可以方便地管理 GDB 启动了：  

```bash
# 多终端复用软件
zellij

# 窗口 1：运行程序，部署端口给 GDB
./gdb.sh serve target/riscv64gc-unknown-none-elf/debug/examples/add

# `Ctrl-t + n` 打开新的窗口 2：运行 GDB
./gdb.sh start target/riscv64gc-unknown-none-elf/debug/examples/add

# zellij 技巧：
# Alt-左右方向键：切换终端
# Ctrl-s + 相应按键：进行页面滚动或者搜索
# Ctrl-t + x：关闭窗口及终端内运行的程序（比手动 kill 进程方便）
```

当然，也可以做成 make 脚本，修改一下作业中 os 目录下的脚本（`make debug` 和 `make disasm`）：

```make
BOOTLOADER := ./bootloader/rustsbi-qemu.bin

# KERNEL ENTRY
KERNEL_ENTRY_PA := 0x80200000

TARGET := riscv64gc-unknown-none-elf
MODE := debug
ELF := target/$(TARGET)/$(MODE)/examples/add

# Emit asm code
OBJDUMP := rust-objdump --arch-name=riscv64 -S

debug:
	@tmux new-session -d \
		"qemu-system-riscv64 -machine virt -nographic -bios $(BOOTLOADER) -device loader,file=$(ELF),addr=$(KERNEL_ENTRY_PA) -s -S" && \
		tmux split-window -h "riscv64-unknown-elf-gdb -ex 'file $(ELF)' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'" && \
		tmux swap-pane -U && \
		tmux -2 attach-session -d

disasm:
	@$(OBJDUMP) $(ELF) | bat -l asm

.PHONY: debug disasm
```

这里面使用的是 tmux，一个更为流行的终端复用工具。

# GDB - tui 命令

首先，由于上述自编译的 GDB 已经自身具有 TUI 模式，所以自己查看说明 `help tui`：

```text
tui disable -- Disable TUI display mode.
tui enable -- Enable TUI display mode.
tui focus, fs, focus -- Set focus to named window or next/prev window.
tui layout, layout -- Change the layout of windows.
tui new-layout -- Create a new TUI layout.
tui refresh, refresh -- Refresh the terminal display.
tui reg -- TUI command to control the register window.
tui window -- Text User Interface window commands.

回到原 tui 模式（区别于 gdb-dashboard）
>>> tui refresh
退出 tui 模式
>>> tui disable

调整上方显示的内容：汇编指令(asm)、源代码 (src)、寄存器 (regs) 以及将它们放在哪里 (split/prev/next)
tui layout asm -- Apply the "asm" layout.
tui layout next -- Apply the next TUI layout.
tui layout prev -- Apply the previous TUI layout.
tui layout regs -- Apply the TUI register layout.
tui layout split -- Apply the "split" layout.
tui layout src -- Apply the "src" layout.

比如进入原 tui 模式会把窗口分割成两个区域：源码和命令
tui layout next 可以把源码区域换成下一个面板（asm）
tui layout split 可以从上方的源码区域切割一个区域，然后拥有了 src、asm 以及命令三个框
此时上下方向键会联动 src 和 asm 来展示内容，但这无法再用它们输入上/下一个历史命令
因此需要 Ctrl-p 和 Ctrl-n 再命令框输入上/下一个历史命令

原 tui 模式非常方便来查看当前指令所在的完整的 src/asm 上下文。
```

![](gdb-TUI-mode.png)

# GDB - dashboard 命令

安装了上述 dashboard 插件，则可以使用 dashboard 命令，使用 `help dashboard` 查看详细信息：

```text
dashboard -configuration -- Dump or save the dashboard configuration.
dashboard -enabled -- Enable or disable the dashboard.
dashboard -layout -- Set or show the dashboard layout.
dashboard -output -- Set the output file/TTY for the whole dashboard or single modules.
dashboard -style -- Access the stylable attributes.
dashboard assembly -- Configure the assembly module, with no arguments toggles its visibility.
dashboard breakpoints -- Configure the breakpoints module, with no arguments toggles its visibility.
dashboard expressions -- Configure the expressions module, with no arguments toggles its visibility.
dashboard history -- Configure the history module, with no arguments toggles its visibility.
dashboard memory -- Configure the memory module, with no arguments toggles its visibility.
dashboard registers -- Configure the registers module, with no arguments toggles its visibility.
dashboard source -- Configure the source module, with no arguments toggles its visibility.
dashboard stack -- Configure the stack module, with no arguments toggles its visibility.
dashboard threads -- Configure the threads module, with no arguments toggles its visibility.
dashboard variables -- Configure the variables module, with no arguments toggles its visibility.
```

GDB 似乎会在命令没有歧义的时候支持短命令，所以 `da` 或者 `dash` 与 `dashboard` 等价。一些命令解释：

* `dashboard`：dashboard 不会固定高度，所以你输入的命令会把 dashboard 挤压掉，所以需要这个命令让 dashboard 位置复原
* `dashboard history` （或者把 history 换成类似的区域名称）：显示/隐藏 那个区域
* `dashboard -layout assembly source`：只显示 assembly 和 source 区域
  * `dashboard -layout assembly breakpoints expressions !history memory registers source stack !threads variables`：
    在不需要的区域前写 `!` 来排除掉那些区域，比如排除掉 history 和 threads
  * `dash -layout !`：恢复默认的布局，显示所有区域
* `dashboard -configuration ~/.gdbinit.d/init`：可将将当前所显示的布局保存到配置文件，下次开启 GDB 只会显示它们。
  需要手动创建 `~/.gdbinit.d` 目录。通常修改区域之后，使用这一步来永久化

